{
  "_args": [
    [
      {
        "raw": "nue@0.7.1",
        "scope": null,
        "escapedName": "nue",
        "name": "nue",
        "rawSpec": "0.7.1",
        "spec": "0.7.1",
        "type": "version"
      },
      "/home/travis/build/Modernizr/Modernizr/node_modules/grunt-istanbul"
    ]
  ],
  "_from": "nue@0.7.1",
  "_id": "nue@0.7.1",
  "_inCache": true,
  "_location": "/nue",
  "_npmUser": {
    "name": "nakamura-to",
    "email": "toshihiro.nakamura@gmail.com"
  },
  "_npmVersion": "1.4.28",
  "_phantomChildren": {},
  "_requested": {
    "raw": "nue@0.7.1",
    "scope": null,
    "escapedName": "nue",
    "name": "nue",
    "rawSpec": "0.7.1",
    "spec": "0.7.1",
    "type": "version"
  },
  "_requiredBy": [
    "/grunt-istanbul"
  ],
  "_resolved": "https://registry.npmjs.org/nue/-/nue-0.7.1.tgz",
  "_shasum": "33523bdf09c98e249fd42d4c928e8cc6c765073f",
  "_shrinkwrap": null,
  "_spec": "nue@0.7.1",
  "_where": "/home/travis/build/Modernizr/Modernizr/node_modules/grunt-istanbul",
  "author": {
    "name": "Toshihiro Nakamura",
    "email": "toshihiro.nakamura@gmail.com"
  },
  "bugs": {
    "url": "https://github.com/nakamura-to/nue/issues"
  },
  "contributors": [],
  "dependencies": {},
  "description": "An async control-flow library suited for node.js.",
  "devDependencies": {
    "mocha": "~2.2.1"
  },
  "directories": {},
  "dist": {
    "shasum": "33523bdf09c98e249fd42d4c928e8cc6c765073f",
    "tarball": "https://registry.npmjs.org/nue/-/nue-0.7.1.tgz"
  },
  "gitHead": "c946f4eaee15577f496ef85968931a97b7ea0d40",
  "homepage": "https://github.com/nakamura-to/nue#readme",
  "keywords": [
    "control-flow",
    "async"
  ],
  "main": "./lib/nue.js",
  "maintainers": [
    {
      "name": "nakamura-to",
      "email": "toshihiro.nakamura@gmail.com"
    }
  ],
  "name": "nue",
  "optionalDependencies": {},
  "readme": "nue â€” An async control-flow library\n===================================\n\nnue is an async control-flow library suited for node.js.\n\n## Installing\n\n```\n$ npm install nue\n```\n\n## Example\n\n```js\nvar flow = require('nue').flow;\nvar as = require('nue').as;\nvar fs = require('fs');\n\nvar myFlow = flow('myFlow')(\n  function readFiles(file1, file2) {\n    fs.readFile(file1, 'utf8', this.async(as(1)));\n    fs.readFile(file2, 'utf8', this.async(as(1)));\n  },\n  function concat(data1, data2) {\n    this.next(data1 + data2);\n  },\n  function end(data) {\n    if (this.err) throw this.err;\n    console.log(data);\n    console.log('done');\n    this.next();\n  }\n);\n\nmyFlow('file1', 'file2');\n```\n\n## API\n\n### Top Level API\n\nThe `nue` module provides following API.\n\n#### flow([Function steps...]) -> Function\n\nReturn a function which represents the control-flow.\n\n* `steps`: Optional. Optional functions to execute in series.\n\n#### flow(String flowName) -> Function\n\nAccept a flow name and return another `flow` function.\n\n* `flowName`: Required. A flow name to be used for debug.\n\n#### parallel([Function steps...]) -> Function\n\nReturn a function which represents the parallel control-flow.\nThe `parallel` must be nested inside a `flow` or another `parallel`.\n\n* `steps`: Optional. Optional functions to execute in parallel.\n\n#### parallel(String flowName) -> Function\n\nAccept a flow name and return another `parallel` function.\n\n* `flowName`: Required. A flow name to be used for debug.\n\n#### as(Number index) -> Object\n\n* `index`: Required. An index to map an asynchronous callback argument to a next step argument.\nIf the index is zero, an error handling is skipped.\n\n\n### Step Context API\n\n`flow` and `parallel` API accept functions called `step`s. Each step context object - it means a `this` object in the step function - provides following API.\n\n#### next([Object values...]) -> Void\n\nA function to execute a next step immediately.  \n\n* `values`: Optional. Arguments for a next step.\n\n#### async([Object mapping]) -> Function\n\nA function to accept an argument mapping definition for a next step and return a callback. \n`async` can be called many times, but all calls are done in same tick. \nAnd all callbacks `async` returns must be called.\n\n* `mapping`: Optional. An argument mapping definition.\n \nTo map single argument, call `as` API and pass its result.  \n\n```js\nfs.readFile('file1', 'utf8', this.async(as(1)));\n```\n\nTo map multiple arguments, pass an object. \n\n```js\nchild_process.exec('whoami', this.async({stdout: as(1), stderr: as(2)}));\n```\n\nTo map multiple arguments except first one, pass no object. You can get result arguments by index.\n\n```js\nchild_process.exec('whoami', this.async());\n```\n\n#### asyncEach(Array array, Function callback(element, group, index, traversedArray)) -> Void\n\nA function to execute a provided function once per array element asynchronously. \n\n* `array`: Required. An array.\n* `callback`: Required. A function being executed once per array element. \nThe context object in the callback is same with outer step context object.\n* `element`: Required. A current element.\n* `group`: Required. Provedes `async` function to accept an argument mapping definition and return a callback.\n* `index`: Required. An element index.\n* `traversedArray`: Required. An array object being traversed.\n\n#### asyncEach(Number concurrency) -> Function\n\nA function to accept a concurrency number and return another `asyncEach` function which \nexecutes a provided function once per array element asynchronously with the specified cuncurrency. \nIf you use another `asyncEach` function directly, default concurrency 10 is used.\n\n* `concurrency`: Required. the number of concurrency.\n\n#### exec(Function function, [Object args...], Function callback(err, [values...])) -> Void\n\nA function to execute a specified `function` with `args` asynchronously. \n\n* `function`: Required. A function to be executed asynchronously.\n* `args`: Optional. Arguments for the `function`.\n* `callback`: Required. A function to be executed when the `function` is completed.\n* `err`: Required. An error in an async call.\n* `values`: Required. Results from the `function`.\n\n#### end([Object values...]) -> Void\n\nA function to execute a last step immediately to end a control-flow.\n\n* `values`: Optional. Arguments for a last step.\n\n#### endWith(Error err) -> Void\n\nA function to execute a last step immediately with an error to end a control-flow. \n\n* `err`: Required. An error object. This object can be referred as `this.err` in a last step.\n\n#### data : Object\n\nA object to share arbitrary data between steps in a control-flow.\n\n#### flowName : String\n\nA flow name.\n\n#### stepName : String\n\nA step name.\n\n#### err : Object\n\nAn error object, which is thrown with `throw`, passed to `this.endWith` or passed to an async callback as first argument.\nThis property is accessible in only last steps.\n\n## More Examples\n\n### Arguments Passing Between Functions\n\nArguments are passed with `this.next` or `this.async`.\n\n#### Synchronously\n\n```js\nvar flow = require('nue').flow;\n\nvar myFlow = flow('myFlow')(\n  function concat(s1, s2) {\n    var length = s1.length + s2.length\n    this.next(s1, s2, length);\n  },\n  function end(s1, s2, length) {\n    if (this.err) throw this.err;\n    console.log(s1 + '.length + ' + s2 + '.length -> ' + length); // file1.length + file2.length -> 10\n    console.log('done');\n    this.next();\n  }\n);\n\nmyFlow('file1', 'file2');\n```\n\n#### Asynchronously\n\nTo pass asynchronous call results to a next function, arguments mapping definition is necessary.\nThe function `as` accepts an index to specify a callback argument and returns arguments mapping definition.\nThe function `this.async` accepts the mapping definition and return a callback.\nWhen all callbacks are completed, the next function is called with specific arguments.\n\n```js\nvar flow = require('nue').flow;\nvar as = require('nue').as;\nvar fs = require('fs');\n\nvar myFlow = flow('myFlow')(\n  function readFiles(file1, file2) {\n    fs.readFile(file1, 'utf8', this.async(as(1)));\n    fs.readFile(file2, 'utf8', this.async(as(1)));\n  },\n  function end(data1, data2) {\n    if (this.err) throw this.err;\n    console.log(data1 + data2); // FILE1FILE2\n    console.log('done');\n    this.next();\n  }\n);\n\nmyFlow('file1', 'file2');\n```\n\nArguments mapping definition can contain arbitrary values.\n\n```js\nvar flow = require('nue').flow;\nvar as = require('nue').as;\nvar fs = require('fs');\n\nvar myFlow = flow('myFlow')(\n  function readFiles(file1, file2) {\n    fs.readFile(file1, 'utf8', this.async({name: file1, data: as(1)}));\n    fs.readFile(file2, 'utf8', this.async({name: file2, data: as(1)}));\n  },\n  function end(f1, f2) {\n    if (this.err) throw this.err;\n    console.log(f1.name + ' and ' + f2.name + ' have been read.'); // file1 and file2 have been read.\n    console.log(f1.data + f2.data); // FILE1FILE2\n    console.log('done');\n    this.next();\n  }\n);\n\nmyFlow('file1', 'file2');\n```\n\n### Asynchronous Loop\n\n`this.asyncEach` executes a provided function once per array element asynchronously.\nBy default, the number of concurrency is 10.\n\n```js\nvar flow = require('nue').flow;\nvar as = require('nue').as;\nvar fs = require('fs');\n\nvar myFlow = flow('myFlow')(\n  function readFiles(files) {\n    this.asyncEach(files, function (file, group) {\n      fs.readFile(file, 'utf8', group.async({name: file, data: as(1)}));\n    });\n  },\n  function end(files) {\n    if (this.err) throw this.err;\n    var names = files.map(function (f) { return f.name; });\n    var contents = files.map(function (f) { return f.data});\n    console.log(names.join(' and ') + ' have been read.'); // file1 and file2 have been read.\n    console.log(contents.join('')); // FILE1FILE2\n    this.next();\n  }\n);\n\nmyFlow(['file1', 'file2']);\n```\n\nTo change the number of concurrency, specify the number as below.\n\n```js\n  function readFiles(files) {\n    this.asyncEach(5)(files, function (file, group) {\n       ...\n    });\n  },\n```\n\n### Flow Nesting\n\nA flow is composable. So it can be nested.\n\n```js\nvar flow = require('nue').flow;\nvar as = require('nue').as;\nvar fs = require('fs');\n\nvar subFlow = flow('subFlow')(\n  function readFile(file) {\n    fs.readFile(file, 'utf8', this.async(as(1)));\n  }\n);\n\nvar mainFlow = flow('mainFlow')(\n  function start() {\n    this.next('file1');\n  },\n  subFlow,\n  function end(result) {\n    if (this.err) throw this.err;\n    console.log(result);\n    console.log('done');\n    this.next();\n  }\n);\n\nmainFlow();\n```\n\n### Asynchronous Flow Execution\n\nA flow can be executed asynchronously.\n\n```js\nvar flow = require('nue').flow;\nvar as = require('nue').as;\nvar fs = require('fs');\n\nvar subFlow = flow('subFlow')(\n  function readFile(file) {\n    fs.readFile(file, 'utf8', this.async(as(1)));\n  }\n);\n\nvar mainFlow = flow('mainFlow')(\n  function start() {\n    this.exec(subFlow, 'file1', this.async(as(1)));\n    this.exec(subFlow, 'file2', this.async(as(1)));\n  },\n  function end(data1, data2) {\n    if (this.err) throw this.err;\n    console.log(data1 + data2);\n    console.log('done');\n    this.next();\n  }\n);\n\nmainFlow();\n```\n\n### Parallel Flow\n\nIn following example, the flow `par1-1` and `par1-2` are executed in parallel.\n\n```js\nvar flow = require('nue').flow;\nvar parallel = require('nue').parallel;\n\nvar myFlow = flow('main')(\n  function one() {\n    console.log(this.stepName);\n    this.next(); \n  },\n  function two() {\n    console.log(this.stepName);\n    this.next(); \n  },\n  parallel('par1')(\n    flow('par1-1')(\n      function three() {\n        console.log(this.stepName);\n        this.next(); \n      },\n      function four() {\n        console.log(this.stepName);\n        this.next(); \n      }\n    ),\n    flow('par1-2')(\n      function five() {\n        console.log(this.stepName);\n        this.next(); \n      },\n      function six() {\n        console.log(this.stepName);\n        this.next(); \n      }\n    )\n  ),\n  function seven() {\n    console.log(this.stepName);\n    this.next(); \n  },\n  function eight() {\n    console.log(this.stepName);\n    this.next(); \n  },\n  function allDone() {\n    if (this.err) throw this.err;\n    console.log(this.stepName);\n    this.next();\n  }\n);\n\nmyFlow();\n```\n\nArguments to a parallel flow are passed to every forked functions.\nParallel flow results are passed to a next funtion as an array.\nThe array contains the results of forked functions.\n\n```js\nvar flow = require('nue').flow;\nvar parallel = require('nue').parallel;\n\nvar myFlow = flow('main')(\n  function start() { \n    this.next(10, 20); \n  },\n  parallel('parallel')(\n    function add(x, y) { \n      this.next(x + y); \n    },\n    function sub(x, y) { \n      this.next(x - y);\n    }\n  ),\n  function end(results) {\n    if (this.err) throw this.err;\n    console.log('add result: ' + results[0]); // add result: 30 \n    console.log('sub result: ' + results[1]); // sub result: -10\n    this.next();\n  }\n);\n\nmyFlow();\n```\n\n### Data Sharing Between Functions\n\nEach step in a flow can share data through `this.data`.\n`this.data` is shared in a same flow.\nA nesting flow and any nested flows can't share `this.data`.\n\n```js\nvar flow = require('nue').flow;\nvar as = require('nue').as;\nvar fs = require('fs');\n\nvar myFlow = flow('myFlow')(\n  function readFiles(file1, file2) {\n    this.data.file1 = file1;\n    this.data.file2 = file2;\n    fs.readFile(file1, 'utf8', this.async(as(1)));\n    fs.readFile(file2, 'utf8', this.async(as(1)));\n  },\n  function concat(data1, data2) {\n    this.next(data1 + data2);\n  },\n  function end(data) {\n    if (this.err) throw this.err;\n    console.log(data);\n    console.log(this.data.file1 + ' and ' + this.data.file2 + ' are concatenated.');\n    this.next();\n  }\n);\n\nmyFlow('file1', 'file2');\n```\n\n### Error Handling\n\nIn a last step in a flow, `this.err` represents an error which is thrown with `throw`, passed to `this.endWith` or passed to an async callback as first argument. \nTo indicate error handling is completed, you must assign `null` to `this.err`.\n\n```js\nvar flow = require('nue').flow;\nvar as = require('nue').as;\nvar fs = require('fs');\n\nvar myFlow = flow('myFlow')(\n  function readFiles(file1, file2) {\n    fs.readFile(file1, 'utf8', this.async(as(1)));\n    fs.readFile(file2, 'utf8', this.async(as(1)));\n  },\n  function concat(data1, data2) {\n    this.next(data1 + data2);\n  },\n  function end(data) {\n    if (this.err) {\n      // handle error\n      console.log(this.err.message);\n      // indicate error handling completion\n      this.err = null;\n    } else {\n      console.log(data);\n    }\n    console.log('done');\n    this.next();\n  }\n);\n\nmyFlow('file1', 'non-existent-file');\n```\n\n### Unit Test with Mocha\n\nFollowing example shows how to test a flow and a function with [Mocha](http://visionmedia.github.com/mocha/).\n\n```js\nvar flow = require('nue').flow;\nvar as = require('nue').as;\nvar fs = require('fs');\n\nvar concatFiles = flow(\n  function (file1, file2) {\n    fs.readFile(file1, 'utf8', this.async(as(1)));\n    fs.readFile(file2, 'utf8', this.async(as(1)));\n  },\n  function (data1, data2) {\n    this.next(data1 + data2);\n  }\n);\n\nfunction read(file) {\n  fs.readFile(file, 'utf8', this.async(as(1)));\n}\n\nvar assert = require('assert');\n\ndescribe('flow `concatFiles`', function () {\n  it('can be tested', function (done) {\n    flow(\n      concatFiles,\n      function (data) {\n        if (this.err) throw this.err;\n        assert.strictEqual(data, 'FILE1FILE2');\n        done();\n      }\n    )('file1', 'file2');\n  });\n});\n\ndescribe('function `read`', function () {\n  it('can be tested', function (done) {\n    flow(\n      read,\n      function (data) {\n        if (this.err) throw this.err;\n        assert.strictEqual(data, 'FILE1');\n        done();\n      }\n    )('file1');\n  });\n});\n```\n\n## Debugging\n\nUse `NODE_DEBUG=nue`. \n\n### Example\n\n> hoge.js\n\n```js\nvar flow = require('nue').flow;\n\nflow('hoge')(\n  function add(x, y) {\n    this.next(x + y);\n  },\n  function done(result) {\n    if (this.err) throw this.err;\n    console.log(result);\n  }\n)(10, 20);\n```\n\n> Run and Output\n\n```sh\n$ NODE_DEBUG=nue node hoge.js\nNUE: begin TOP_LEVEL_FLOW. flow: hoge(0), calledAt: /private/tmp/hoge.js:11:1, args: [ 10, 20 ]\nNUE: begin STEP. flow: hoge(0), step: add(0), args: [ 10, 20 ]\nNUE: begin STEP. flow: hoge(0), step: done(1), args: [ 30 ]\n30\n```\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/nakamura-to/nue.git"
  },
  "scripts": {
    "test": "mocha test"
  },
  "version": "0.7.1"
}
